{"parameter":"ehz","value":"0.084140","min":"-inf","max":"inf","description":"Motor electrical hz"}
{"parameter":"enc_angle","value":"0","min":"0","max":"65535","description":"Encoder angle now"}
{"parameter":"enc_counts","value":"4096","min":"0","max":"65535","description":"Encoder ABI PPR"}
{"parameter":"enc_offset","value":"25000","min":"0","max":"65535","description":"Encoder alignment angle"}
{"parameter":"enc_polarity","value":"0","min":"0","max":"1","description":"Encoder polarity"}
{"parameter":"error","value":"0","min":"0","max":"4294967295","description":"System errors now"}
{"parameter":"error_all","value":"134217744","min":"0","max":"4294967295","description":"All errors encountered"}
{"parameter":"flux","value":"0.004500","min":"0.00","max":"100.00","description":"Flux linkage"}
{"parameter":"flux_gain","value":"0.670820","min":"0.00","max":"100.00","description":"Flux linkage gain"}

adc1	0	0	4096	Raw ADC throttle
adc1_max	2700	0	4096	ADC1 max val
adc1_min	600	0	4096	ADC1 min val
adc1_pol	1.000000	-1.00	1.00	ADC1 polarity
adc2_max	4095	0	4096	ADC2 max val
adc2_min	1200	0	4096	ADC2 min val
adc2_pol	1.000000	-1.00	1.00	ADC2 polarity
can_adc	11	0	254	CAN ADC ID  0=disabled
curr_max	40.000000	0.00	300.00	Max motor current
curr_min	-10.000000	-300.00	0.00	Min motor current
direction	0	0	1	Motor direction
ehz	0.084140	-inf	inf	Motor electrical hz
enc_angle	0	0	65535	Encoder angle now
enc_counts	4096	0	65535	Encoder ABI PPR
enc_offset	25000	0	65535	Encoder alignment angle
enc_polarity	0	0	1	Encoder polarity
error	0	0	4294967295	System errors now
error_all	134217744	0	4294967295	All errors encountered
flux	0.004500	0.00	100.00	Flux linkage
flux_gain	0.670820	0.00	100.00	Flux linkage gain
flux_n_lin	5000.000000	0.00	10000.00	Flux centering gain
FOC_angle	57358	0	65535	FOC angle now
fw_curr	36.000000	0.00	300.00	Max field weakenning current
fw_ehz	0.000000	0.00	6000.00	max eHz under field weakenning
Hall_flux	Array[12]	-10.00	10.00	hall start table
Hall_initialised	1	0	1	hall start flag
hfi_gain	0.000000	0.00	5000.00	HFI gain
hfi_mod_didq	0.000000	0.00	2.00	HFI mod didq
hfi_type	0	0	3	HFI type [0=None, 1=45deg, 2=d axis]
hfi_volt	4.000000	0.00	50.00	HFI voltage
i_max	500.000000	0.00	500.00	Max current
id	-0.004902	-inf	inf	Phase Idq_d smoothed
input_opt	1	0	128	Inputs [1=ADC1 2=ADC2 4=PPM 8=UART 16=Killswitch 32=CANADC1 64=CANADC2 128=ADC12DIFF]
iq	-0.041515	-inf	inf	Phase Idq_q smoothed
iqreq	0.019048	-4096.00	4096.00	mtr[0].FOC.Idq_req.q
ld_phase	0.000043	0.00	10.00	Phase inductance
lq_phase	0.000064	0.00	10.00	Phase inductance
motor_pp	28	0	30	Number of motor pole PAIRS
motor_sensor	0	0	30	0=SL, 1=Hall, 2=OL, 3=ABSENC, 4=INC_ENC, 5=HFI
node_id	0	1	254	Node ID
ol_step	0	0	6000	Angle per PWM period openloop
p_max	12000.000000	0.00	50000.00	Max power
park_curr	0.000000	0.00	300.00	max current for handbrake
password		Password for SU
pole_pairs	28	0	255	Motor pole pairs
pwm_freq	20000.000000	0.00	100000.00	PWM frequency
r_phase	0.070000	0.00	10.00	Phase resistance
rpm_max	0	0	300000	Max RPM
safe_count	100	0	1000	Live count before allowing throttle
safe_start	100	0	1000	Countdown before allowing throttle
SL_sensor	0	0	30	0=OL, 1=Hall, 2=PWMENC, 3=HFI
TMOS	299.012939	0.00	4096.00	MOSFET temp, kelvin
TMOT	210.450562	0.00	4096.00	Motor temp, kelvin
uart_dreq	0.000000	-1000.00	1000.00	Uart input
uart_req	0.000000	-1000.00	1000.00	Uart input
v_max	0.000000	0.00	600.00	Max voltage
vbus	54.493359	0.00	inf	Read input voltage
Vd	0.019072	-4096.00	4096.00	FOC_Vdq_d
Vq	-0.078574	-4096.00	4096.00	FOC_Vdq_q


<tr>
  <th>Variable</th>
  <th>Value</th>
  <th>min</th>
  <th>max</th>
  <th>note</th>
</tr>
<tr>
  <td>adc1_max</td>
  <td>string1</td>
  <td>string2</td>
  <td>string3</td>
  <td>string4</td>
</tr>
<tr>
  <td>curr_max</td>
  <td>string1</td>
  <td>string2</td>
  <td>string3</td>
  <td>string4</td>
</tr>
<tr>
  <td>v_max</td>
  <td>string1</td>
  <td>string2</td>
  <td>string3</td>
  <td>string4</td>
</tr>


void stringToJSON(const char* data) {
    // Create a JSON document
    StaticJsonDocument<256> doc;

    // Make a mutable copy of the input string
    char inputCopy[256];
    strncpy(inputCopy, data, sizeof(inputCopy));
    inputCopy[sizeof(inputCopy) - 1] = '\0'; // Ensure null-termination
    
    // Parse the input string
    char* token = strtok(inputCopy, "\t");
    int index = 0;
    const char* field1 = "";
    const char* field2 = "";
    const char* field3 = "";
    const char* field4 = "";
    const char* field5 = "";

    while (token != NULL) {
        if (index == 0) field1 = token;
        else if (index == 1) field2 = token;
        else if (index == 2) field3 = token;
        else if (index == 3) field4 = token;
        else if (index == 4) field5 = token;
        
        token = strtok(NULL, "\t");
        index++;
    }
    
    // Populate the JSON document
    doc["parameter"] = field1;
    doc["value"] = field2;
    doc["min"] = field3;
    doc["max"] = field4;
    doc["description"] = field5;

    // Serialize JSON to string
    char output[256];
    size_t bytesWritten = serializeJson(doc, output, sizeof(output));
    
    // Check if the serialization was successful
    if (bytesWritten == 0) {
        Serial.println("Serialization failed");
    } else {
        // Verify the content of the JSON string
        StaticJsonDocument<256> verifyDoc;
        DeserializationError error = deserializeJson(verifyDoc, output);

        if (error) {
            Serial.print("Deserialization failed: ");
            Serial.println(error.c_str());
	}
	else {

	  if (webSocket.connectedClients() > 0) {
	    Serial.println(output);
	    Serial.print("Serialized JSON length: ");
	    Serial.println(bytesWritten);
	    webSocket.broadcastTXT(output);
	  }
        }
    }
}
