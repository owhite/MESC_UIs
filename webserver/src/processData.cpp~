#include "processData.h"

char serialBuffer[BUFFER_SIZE];
int bufferIndex = 0;
SemaphoreHandle_t mutex;
unsigned long lastReceiveTime = 0;

void initProcessData() {
    // Create the mutex
    mutex = xSemaphoreCreateMutex();
    if (mutex == NULL) {
        Serial.println("Mutex creation failed!");
        while (true);
    }

    // Create the task to process the serial data
    xTaskCreate(
        processData,     // Task function
        "Process Data",  // Name of the task
        2048,            // Stack size
        NULL,            // Parameter
        1,               // Priority
        NULL             // Task handle
    );
}

// Implementation of memcat function
void *memcat(void *dest, size_t dest_len, const void *src, size_t src_len) {
    // Calculate the start position for concatenation
    void *concat_position = (char *)dest + dest_len;

    // Copy the source memory to the destination
    memcpy(concat_position, src, src_len);

    return dest;
}

// Function to process a complete line
void processLine(char *line) {
    Serial.print("Processing data: ");
    Serial.println(line);
}

void processData(void *parameter) {
    char localBuffer[BUFFER_SIZE];
    int localBufferIndex = 0;

    while (true) {
        if (xSemaphoreTake(mutex, portMAX_DELAY) == pdTRUE) {
            if (bufferIndex > 0) {
                memcat(localBuffer, localBufferIndex, serialBuffer, bufferIndex);
                localBufferIndex += bufferIndex;

                // Clear the global buffer
                bufferIndex = 0;
                serialBuffer[bufferIndex] = '\0';
                lastReceiveTime = millis();
            }
            xSemaphoreGive(mutex);

            // Check if the local buffer has a complete line (ending with '\n')
            for (int i = 0; i < localBufferIndex; i++) {
                if (localBuffer[i] == '\n') {
                    // Null-terminate the line for processing
                    localBuffer[i] = '\0';
                    
                    // Process the complete line
                    processLine(localBuffer);

                    // Shift remaining data to the beginning of the buffer
                    int remainingLength = localBufferIndex - (i + 1);
                    memmove(localBuffer, localBuffer + i + 1, remainingLength);
                    localBufferIndex = remainingLength;
                    i = -1; // Reset the loop to process any additional complete lines
                }
            }

            // Check if timeout has occurred and there is data in the buffer
            if (localBufferIndex > 0 && (millis() - lastReceiveTime) >= TIMEOUT_MS) {
                localBuffer[localBufferIndex] = '\0'; // Null-terminate the buffer
                processLine(localBuffer); // Process the buffer as a complete line
                localBufferIndex = 0; // Reset the buffer index
            }
        }

        vTaskDelay(100 / portTICK_PERIOD_MS);
    }
}
